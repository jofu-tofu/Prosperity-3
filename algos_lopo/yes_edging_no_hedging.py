# -*- coding: utf-8 -*-
"""jakes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KDMnJVwSSnOXK4CaRyw2bhRvAEw9zLUR
"""

import json
from datamodel import Listing, Observation, Order, OrderDepth, ProsperityEncoder, Symbol, Trade, TradingState
from typing import Any
from typing import List
import string
import pandas as pd
import numpy as np
from math import *
from typing import Dict, List
from datamodel import OrderDepth, TradingState, Order
import collections
from collections import defaultdict
import random
import math
import copy
import numpy as np

empty_dict = {'AMETHYSTS' : 0, 'STARFRUIT' : 0, 'STRAWBERRIES' : 0, 'COCONUT_COUPON' : 0, 'COCONUT': 0, 'ORCHIDS' : 0, 'ROSES' : 0, 'CHOCOLATE' : 0, 'STRAWBERRIES' : 0, 'GIFT_BASKET' : 0}

def def_value():
    return copy.deepcopy(empty_dict)

class Trader:
    person_position = defaultdict(def_value)
    person_actvalof_position = defaultdict(def_value)
    def norm_pdf(x):
        return 1 / np.sqrt(2 * np.pi) * np.exp(-0.5 * x**2)

    def call_option_price(S, K, T, r, sigma):
        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
        d2 = d1 - sigma * np.sqrt(T)
        return S * Trader.norm_cdf(d1) - K * np.exp(-r * T) * Trader.norm_cdf(d2)

    def norm_cdf(x):
        return (1 + erf(x / np.sqrt(2))) / 2

    def implied_volatility(S, C, T, K = 10000, r = 0, max_iter=1000, tol=1e-9):
        sigma = 0.5
        for i in range(max_iter):
            price = Trader.call_option_price(S, K, T, r, sigma)
            vega = S * np.sqrt(T) * Trader.norm_pdf((np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T)))
            if abs(price - C) < tol:
                return sigma
            sigma -= (price - C) / vega
        return sigma


    def N(x):
        return float((1.0 + erf(x / sqrt(2.0))) / 2.0)

    def cdf(x):
      return np.array(pd.Series(x).apply(lambda x: Trader.N(x)))

    def black_scholes(S, T, K = 10000, r = 0, sigma = 0.16, option_type='call'):
      # Calculate d1 and d2 components
      d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
      d2 = d1 - sigma * np.sqrt(T)

      if option_type == 'call':
          # Calculate call price using Black-Scholes formula
          call_price = (S * Trader.N(d1) - K * np.exp(-r * T) * Trader.N(d2))
          return call_price
      elif option_type == 'put':
          # Calculate put price using Black-Scholes formula
          put_price = (K * np.exp(-r * T) * Trader.N(-d2) - S * Trader.N(-d1))
          return put_price
      else:
          raise ValueError("option_type must be either 'call' or 'put'")

    RhiannaBought = False
    RhiannaSold = False

    def run(self, state: TradingState):
        # print("traderData: " + state.traderData)
        # print("Observations: " + str(state.observations))
        # print("Own trades starfruit: " + str(state.own_trades.get('STARFRUIT', [])))
        # print("Own trades amethyst: " + str(state.own_trades.get('AMETHYST', [])))
        # print("Own trades orchids: " + str(state.own_trades.get('ORCHIDS', [])))
        # print("Own trades baskets: " + str(state.own_trades.get('GIFT_BASKET', [])))
        # print("Own trades coconuts: " + str(state.own_trades.get('COCONUT', [])))
        # print("Own trades coupons: " + str(state.own_trades.get('COCONUT_COUPON', [])))

        result = {}
        flag1 = False
        flag2 = False
        flag3 = False
        flag4 = False
        for product in state.market_trades.keys():
          for trade in state.market_trades[product]:
            if trade.buyer == trade.seller:
                continue
            if trade.timestamp +100 == state.timestamp:
                self.person_position[trade.buyer][product] = 1
                self.person_position[trade.seller][product] = -1
                self.person_actvalof_position[trade.buyer][product] += trade.quantity
                self.person_actvalof_position[trade.seller][product] += -trade.quantity


        for starfruit_trade in state.market_trades.get('ROSES', []):
          if starfruit_trade.buyer == 'Rhianna' and state.timestamp == starfruit_trade.timestamp + 100:
              self.RhiannaBought = True
          if starfruit_trade.seller == 'Rhianna' and state.timestamp == starfruit_trade.timestamp + 100:
              self.RhiannaSold = True


        product = 'COCONUT'
        order_depth: OrderDepth = state.order_depths[product]
        orders_coco: List[Order] = []
        position: int = state.position.get(product, 0)
        max_coco_buy = 300 - position
        max_coco_sell = -300 - position
        coco_position = position


        if len(order_depth.sell_orders) != 0:
          best_coco_ask = list(order_depth.sell_orders.items())[0][0]
          volume_coco_ask = list(order_depth.sell_orders.items())[0][1]
          flag1 = True
        if len(order_depth.buy_orders) != 0:
          best_coco_bid = list(order_depth.buy_orders.items())[0][0]
          volume_coco_bid = list(order_depth.buy_orders.items())[0][1]
          flag2 = True
        if flag1 and flag2:
          coco_price = (best_coco_bid + best_coco_ask)/2

        product = 'COCONUT_COUPON'
        order_depth: OrderDepth = state.order_depths[product]
        orders_coupon: List[Order] = []
        position: int = state.position.get(product, 0)
        max_coupon_buy = 600 - position
        max_coupon_sell = -600 - position
        coupon_position = position


        if len(order_depth.sell_orders) != 0:
          best_coupon_ask = list(order_depth.sell_orders.items())[0][0]
          volume_coupon_ask = list(order_depth.sell_orders.items())[0][1]
          flag3 = True
        if len(order_depth.buy_orders) != 0:
          best_coupon_bid = list(order_depth.buy_orders.items())[0][0]
          volume_coupon_bid = list(order_depth.buy_orders.items())[0][1]
          flag4 = True
        if flag3 and flag4:
          coupon_price = (best_coupon_ask + best_coupon_bid)/2

        threshold = 5
        if flag1 and flag2 and flag3 and flag4:
          time_day = state.timestamp / 1000000
          T = (246 - time_day)/250
          call_price = Trader.black_scholes(coco_price, T)
          spread_sell = best_coupon_bid - call_price
          spread_buy = call_price - best_coupon_ask
          spread = coupon_price - call_price

          if spread_sell > threshold:

            #vol = min(abs(max_coco_buy), abs(volume_coco_ask), volume_coupon_bid // 2, abs(max_coupon_sell) // 2)
            # if spread_sell > threshold:
            #   coco_vol = max_coco_buy // 5
            #   orders_coco.append(Order('COCONUT', best_coco_ask, coco_vol))
            coupon_vol = max_coupon_sell
            orders_coupon.append(Order('COCONUT_COUPON', best_coupon_bid, coupon_vol))

          if spread_buy > threshold:
            #vol = min(abs(max_coco_sell), volume_coco_bid, abs(volume_coupon_ask), abs(max_coupon_buy) // 2)
            # if spread_buy > threshold:
            #   coco_vol = max_coco_sell // 5
            #   orders_coco.append(Order('COCONUT', best_coco_bid, coco_vol))
            coupon_vol =  max_coupon_buy
            orders_coupon.append(Order('COCONUT_COUPON', best_coupon_ask, coupon_vol))

          # coco_target = -coupon_position // 2
          # if coco_target - coco_position > 0:
          #   orders_coco.append(Order('COCONUT', best_coco_ask, coco_target - coco_position))
          # else:
          #   orders_coco.append(Order('COCONUT', best_coco_bid, coco_target - coco_position))

          # rhi_delta = 10

          # if self.person_actvalof_position['Rhianna']['COCONUT'] > rhi_delta:
          #     orders_coco.append(Order('COCONUT', best_coco_ask, max_coco_buy))
          # elif self.person_actvalof_position['Rhianna']['COCONUT'] < -rhi_delta:
          #     orders_coco.append(Order('COCONUT', best_coco_bid, max_coco_sell))


        result['COCONUT'] = orders_coco
        result['COCONUT_COUPON'] = orders_coupon


        flagBASKET = False

        flagSTRAWBERRIES = False

        flagROSES = False

        flagCHOCOLATE = False

        orders_basket: list[Order] = []

        orders_ROSES: list[Order] = []

        orders_STRAWBERRIES: list[Order] = []

        orders_CHOCOLATE: list[Order] = []

        product = "GIFT_BASKET"

        basket_order_depth: OrderDepth = state.order_depths[product]

        basket_position: int = state.position.get(product, 0)

        basket_best_ask = min(basket_order_depth.sell_orders.keys())
        basket_best_bid = max(basket_order_depth.buy_orders.keys())

        mid_basket = (basket_best_ask + basket_best_bid)//2

        basket_best_ask_volume = basket_order_depth.sell_orders[basket_best_ask]
        basket_best_bid_volume = basket_order_depth.buy_orders[basket_best_bid]

        max_basket_sell = - 60 - basket_position
        max_basket_buy = 60 - basket_position

        flagBASKET = True

        product = "STRAWBERRIES"

        STRAWBERRIES_order_depth: OrderDepth = state.order_depths[product]

        STRAWBERRIES_position: int = state.position.get(product, 0)

        STRAWBERRIES_best_ask = min(STRAWBERRIES_order_depth.sell_orders.keys())
        STRAWBERRIES_best_bid = max(STRAWBERRIES_order_depth.buy_orders.keys())

        mid_STRAWBERRIES = (STRAWBERRIES_best_ask + STRAWBERRIES_best_bid) // 2

        STRAWBERRIES_best_ask_volume = STRAWBERRIES_order_depth.sell_orders[STRAWBERRIES_best_ask]
        STRAWBERRIES_best_bid_volume = STRAWBERRIES_order_depth.buy_orders[STRAWBERRIES_best_bid]

        max_STRAWBERRIES_sell = - 350 - STRAWBERRIES_position
        max_STRAWBERRIES_buy = 350 - STRAWBERRIES_position

        flagSTRAWBERRIES = True

        product = "ROSES"

        ROSES_order_depth: OrderDepth = state.order_depths[product]

        ROSES_position: int = state.position.get(product, 0)

        ROSES_best_ask = min(ROSES_order_depth.sell_orders.keys())
        ROSES_best_bid = max(ROSES_order_depth.buy_orders.keys())

        mid_ROSES = (ROSES_best_ask + ROSES_best_bid)//2

        ROSES_best_ask_volume = ROSES_order_depth.sell_orders[ROSES_best_ask]
        ROSES_best_bid_volume = ROSES_order_depth.buy_orders[ROSES_best_bid]

        max_ROSES_sell = - 60 - ROSES_position
        max_ROSES_buy = 60 - ROSES_position

        flagROSES = True

        product = "CHOCOLATE"

        CHOCOLATE_order_depth: OrderDepth = state.order_depths[product]

        CHOCOLATE_position: int = state.position.get(product, 0)

        CHOCOLATE_best_ask = min(CHOCOLATE_order_depth.sell_orders.keys())
        CHOCOLATE_best_bid = max(CHOCOLATE_order_depth.buy_orders.keys())

        mid_CHOCOLATE = (CHOCOLATE_best_ask + CHOCOLATE_best_bid) // 2

        CHOCOLATE_best_ask_volume = CHOCOLATE_order_depth.sell_orders[CHOCOLATE_best_ask]
        CHOCOLATE_best_bid_volume = CHOCOLATE_order_depth.buy_orders[CHOCOLATE_best_bid]

        max_CHOCOLATE_sell = - 250 - CHOCOLATE_position
        max_CHOCOLATE_buy = 250 - CHOCOLATE_position

        flagCHOCOLATE = True

        if flagCHOCOLATE and flagBASKET and flagSTRAWBERRIES and flagROSES:

            B1 = 15
            B2 = 15
            rho = 0.7

            spread = mid_basket - 375 - 6 * mid_STRAWBERRIES - 4 * mid_CHOCOLATE - mid_ROSES
            etf = 6 * mid_STRAWBERRIES + 4 * mid_CHOCOLATE + mid_ROSES

            if spread > B1:
                orders_basket.append(Order('GIFT_BASKET', basket_best_bid, max_basket_sell))

            elif spread < -B1:
                orders_basket.append(Order('GIFT_BASKET', basket_best_ask, max_basket_buy))

            if self.RhiannaSold:
                orders_ROSES.append(Order('ROSES', ROSES_best_bid, max_ROSES_sell))
                if max_ROSES_sell == 0:
                    self.RhiannaSold = False
            elif self.RhiannaBought:
                orders_ROSES.append(Order('ROSES', ROSES_best_ask, max_ROSES_buy))
                if max_ROSES_buy == 0:
                    self.RhiannaBought = False

            result['ROSES'] = orders_ROSES
            result['GIFT_BASKET'] = orders_basket

        for product in state.order_depths:
          if product == 'STARFRUIT':
            order_depth: OrderDepth = state.order_depths[product]
            orders: List[Order] = []
            position: int = state.position.get(product, 0)
            max_buy = 20 - position
            max_sell = -20 - position
            print("POSITION", position)
            total_amount = 0
            acceptable_price = 0
            if len(order_depth.sell_orders) != 0:
              for ask, amount in list(order_depth.sell_orders.items()):
                acceptable_price += abs(ask * amount)
                total_amount += abs(amount)
            if len(order_depth.buy_orders) != 0:
              for bid, amount in list(order_depth.buy_orders.items()):
                acceptable_price += abs(bid * amount)
                total_amount += abs(amount)
            acceptable_price = int(acceptable_price/total_amount)
            if len(order_depth.sell_orders) != 0:
                for ask, amount in list(order_depth.sell_orders.items()):
                    if int(ask) < acceptable_price:
                        buy_volume = max(min(-amount, max_buy), 0)
                        print("BUY", str(-buy_volume) + "x", ask)
                        orders.append(Order(product, ask, buy_volume))
                        max_buy = max_buy - buy_volume
                        position = position + buy_volume
                    elif int(ask) <= acceptable_price and position < 0:
                        buy_volume = max(min(-amount, -position), 0)
                        print("BUY", str(-buy_volume) + "x", ask)
                        orders.append(Order(product, ask, buy_volume))
                        max_buy = max_buy - buy_volume
                        position = position + buy_volume

            if len(order_depth.buy_orders) != 0:
                for bid, amount in list(order_depth.buy_orders.items()):
                    if int(bid) > acceptable_price:
                        sell_volume = min(max(-amount, max_sell), 0)
                        print("SELL", str(sell_volume) + "x", bid)
                        orders.append(Order(product, bid, sell_volume))
                        max_sell = max_sell - sell_volume
                        position = position + sell_volume
                    elif int(bid) >= acceptable_price and position > 0:
                        sell_volume = min(max(-amount, -position), 0)
                        print("SELL", str(sell_volume) + "x", bid)
                        orders.append(Order(product, bid, sell_volume))
                        max_sell = max_sell - sell_volume
                        position = position + sell_volume

            if max_sell != 0:
              sell_threshold = list(order_depth.sell_orders.items())[-1][0]
              orders.append(Order(product, sell_threshold - 1, max_sell))
            if max_buy != 0:
              buy_threshold = list(order_depth.buy_orders.items())[-1][0]
              orders.append(Order(product, buy_threshold + 1, max_buy))


            result[product] = orders


          if product == 'AMETHYSTS':
            order_depth: OrderDepth = state.order_depths[product]
            orders: List[Order] = []
            position: int = state.position.get(product, 0)
            print('POSITION: ' + str(position))
            max_buy = 20 - position
            max_sell = -20 - position
            total_amount = 0
            acceptable_price = 0
            if len(order_depth.sell_orders) != 0:
              for ask, amount in list(order_depth.sell_orders.items()):
                acceptable_price += abs(ask * amount)
                total_amount += abs(amount)
            if len(order_depth.buy_orders) != 0:
              for bid, amount in list(order_depth.buy_orders.items()):
                acceptable_price += abs(bid * amount)
                total_amount += abs(amount)
            acceptable_price = 10000
            print("Acceptable price : " + str(acceptable_price))
            print("Buy Order depth : " + str(len(order_depth.buy_orders)) + ", Sell order depth : " + str(len(order_depth.sell_orders)))

            if len(order_depth.sell_orders) != 0:
              for ask, amount in list(order_depth.sell_orders.items()):
                if int(ask) < acceptable_price:
                  buy_volume = max(min(-amount, max_buy), 0)
                  print("BUY", str(-buy_volume) + "x", ask)
                  orders.append(Order(product, ask, buy_volume))
                  max_buy = max_buy - buy_volume
                  position = position + buy_volume

                if ask == 10000 and position < 0:
                  buy_volume = min(-amount, -position)
                  print("BUY", str(-buy_volume) + "x", ask)
                  orders.append(Order(product, ask, buy_volume))
                  max_buy = max_buy - buy_volume
                  position = position + buy_volume

            if len(order_depth.buy_orders) != 0:
              for bid, amount in list(order_depth.buy_orders.items()):
                if int(bid) > acceptable_price:
                  sell_volume = min(max(-amount, max_sell), 0)
                  print("SELL", str(sell_volume) + "x", bid)
                  orders.append(Order(product, bid, sell_volume))
                  max_sell = max_sell - sell_volume
                  position = position + sell_volume

                if bid == 10000 and position > 0:
                  sell_volume = max(-amount, -position)
                  print("SELL", str(sell_volume) + "x", bid)
                  orders.append(Order(product, bid, sell_volume))
                  max_sell = max_sell - sell_volume
                  position = position + sell_volume

            if len(order_depth.sell_orders) != 0 and list(order_depth.sell_orders.items())[0][0] == 10005 or (list(order_depth.sell_orders.items())[0][0] == 10004 and list(order_depth.sell_orders.items())[0][1] == -1):
              orders.append(Order(product, acceptable_price + 4, max_sell))
            elif len(order_depth.sell_orders) != 0 and list(order_depth.sell_orders.items())[0][0] == 10003:
              orders.append(Order(product, acceptable_price + 2, max_sell))
            elif len(order_depth.sell_orders) != 0 and list(order_depth.sell_orders.items())[0][0] == 10002:
              orders.append(Order(product, acceptable_price + 1, max_sell))
            elif len(order_depth.sell_orders) != 0 and list(order_depth.sell_orders.items())[0][0] == 10000 and position > 0:
              orders.append(Order(product, acceptable_price, -position))
            else:
              orders.append(Order(product, acceptable_price + 3, max_sell))

            if len(order_depth.buy_orders) != 0 and list(order_depth.buy_orders.items())[0][0] == 9995 or (list(order_depth.buy_orders.items())[0][0] == 9996 and list(order_depth.buy_orders.items())[0][1] == 1):
              orders.append(Order(product, acceptable_price - 4, max_buy))
            elif len(order_depth.buy_orders) != 0 and list(order_depth.buy_orders.items())[0][0] == 9997:
              orders.append(Order(product, acceptable_price - 2, max_buy))
            elif len(order_depth.buy_orders) != 0 and list(order_depth.buy_orders.items())[0][0] == 9998:
              orders.append(Order(product, acceptable_price - 1, max_buy))
            elif len(order_depth.buy_orders) != 0 and list(order_depth.buy_orders.items())[0][0] == 10000 and position < 0:
              orders.append(Order(product, acceptable_price, -position))
            else:
              orders.append(Order(product, acceptable_price - 3, max_buy))

            result[product] = orders

        for product in state.order_depths:
          if product == 'ORCHIDS':
            order_depth: OrderDepth = state.order_depths[product]
            orders: List[Order] = []
            position: int = state.position.get(product, 0)
            bidPrice = state.observations.conversionObservations['ORCHIDS'].bidPrice
            askPrice = state.observations.conversionObservations['ORCHIDS'].askPrice
            transportFees = state.observations.conversionObservations['ORCHIDS'].transportFees
            importTariff = state.observations.conversionObservations['ORCHIDS'].importTariff
            exportTariff = state.observations.conversionObservations['ORCHIDS'].exportTariff
            sunlight = state.observations.conversionObservations['ORCHIDS'].sunlight
            humidity = state.observations.conversionObservations['ORCHIDS'].humidity

            fair_buy_price = askPrice + transportFees + importTariff
            fair_sell_price = bidPrice - transportFees - exportTariff - 0.1

            best_ask = list(order_depth.sell_orders.items())[0][0]

            our_price = int(bidPrice - 0.5)

            if our_price > fair_buy_price:
              orders.append(Order(product, our_price, -100))
            elif fair_sell_price - 1 > best_ask:
              orders.append(Order(product, best_ask, 100))
            else:
              market_take = 0
              for bid, amount in list(order_depth.buy_orders.items()):
                if bid > int(fair_buy_price + 0.5):
                  orders.append(Order(product, bid, -amount))
                  market_take += amount
              best_bid = list(order_depth.buy_orders.items())[0][0]
              if best_bid > int(fair_buy_price + 0.5):
                orders.append(Order(product, best_bid, min(-100 + market_take,0)))
              else:
                orders.append(Order(product, int(fair_buy_price) + 2, min(-100 + market_take,0)))


            result[product] = orders


		    # String value holding Trader state data required.
				# It will be delivered as TradingState.traderData on next execution.
        traderData = "SAMPLE"

				# Sample conversion request. Check more details below.
        position: int = state.position.get('ORCHIDS', 0)
        conversions = -position

        return result, conversions, traderData